1. What is the purpose of the next() function, and how does it contribute to the compilation process?
The next() function is responsible for tokenizing the input source code. It reads characters from the input buffer (p),
identifies tokens (such as keywords, identifiers, numbers, operators, and punctuation), and sets the global variable tk
to represent the current token.

Contribution to Compilation Process:
- It breaks down the source code into meaningful tokens that the parser can process.
- It recognizes keywords, variables, numbers, and operators, converting them into predefined token values.
- It updates global variables used in parsing, such as ival (for numeric values) and id (for identifiers).
- It supports handling of special cases like comments, preprocessor directives, and string literals.

2. How does C4 handle symbol resolution (e.g., variables, functions)?
C4 manages symbols using a simple symbol table (sym) implemented as a list of integers. Each entry in the symbol table consists of:
- Tk – Token type (e.g., Id, Fun, Glo, Loc).
- Hash – Hash value for quick lookup.
- Name – Pointer to the identifier name.
- Class – Storage class (Loc for local variables, Glo for global, Sys for system functions).
- Type – Data type (INT, CHAR, PTR).
- Val – Value of a constant or function address.

Resolution Process:
1. Identifiers are stored in the symbol table during tokenization (next() function).
2. When an identifier is encountered in parsing, it is looked up in the symbol table.
3. If it is a function call, the function’s address is used.
4. If it is a variable, its memory location is determined:
   - Local variables use offsets from the stack frame (LEA opcode).
   - Global variables use direct memory addresses.
5. If the identifier is not found, an error is reported.

3. What are the limitations of C4 as a compiler? What features of C does it not support?
C4 is a minimalistic C compiler designed to self-host and execute simple programs. It has several limitations:

Unsupported Features:
- No struct, union, or typedef support – Only int and char types (with pointers) are supported.
- Limited standard library – Only a few system calls (printf, malloc, free, etc.).
- No floating-point support – It only handles integer arithmetic.
- No function overloading or complex expressions – Simple function calls are supported, but no advanced function features.
- No comprehensive error handling – It assumes well-formed input and has minimal error reporting.
- No complex optimizations – It generates a simple virtual machine (VM) bytecode instead of optimized machine code.

4. How does C4 achieve self-hosting (i.e., compiling itself)? What are the implications of this design?
C4 achieves self-hosting by implementing only the essential features needed to compile its own source code. The process involves:
1. Parsing and Translating Its Own Code – C4 can tokenize and parse a subset of C, which is sufficient to describe its own structure.
2. Generating Bytecode for a Virtual Machine (VM) – Instead of direct machine code, C4 compiles to a simple stack-based virtual machine.
3. Executing the Bytecode – The VM executes the generated bytecode, effectively running the compiled program, including a newer version of itself.

Implications of This Design:
- Portability – Since it runs on a VM, C4 can be executed on different architectures without modification.
- Simplicity – It avoids the complexity of directly generating native machine code.
- Limited Features – To remain self-hosting, C4 only supports a subset of C.
